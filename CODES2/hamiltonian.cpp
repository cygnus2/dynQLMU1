/* construct the Hamiltonian matrix from the basis vectors */
// This constructs the Hamiltonian in a chosen winding number basis
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<fstream>
#include<math.h>
#include<vector>
#include<algorithm>
#include "define.h"
#include "mkl.h"
#include "mkl_solvers_ee.h"
#include "mkl_types.h"

void constH(int sector){

   extern void eigcheck(std::vector<double>&, std::vector<std::vector<double>>&,int);
   extern void diag_LAPACK_RRR(MKL_INT, std::vector<double>&, std::vector<double>&);
   extern void diag_LAPACK(MKL_INT, std::vector<double>&, std::vector<double>&);
   extern void printmatrix(std::vector<MKL_INT>&,std::vector<MKL_INT>&,std::vector<double>&);

   int chk1,chk2; //just to check results between scan, binscan and binscan2. Delete later!
   // workspace variables to construct the Hamiltonian
   int i,j,k,p,q,r;
   int p1,p2,p3,p4;
   int q1,q2,q3,q4;
   int x1,x2,x3,x4;
   int y1,y2,y3,y4;
   int ix,iy;
   int n_Flip;
   int stateq,curr_index;
   bool pxy,pyz,pzw,pwx;
   bool qxy,qyz,qzw,qwx;
   std::vector<bool> newstate(2*VOL);
   std::vector<int> rowscan(VOL+1);
   // rowscan stores the elements of the cartoon states generated by the action of the Hamiltonian
   // the maximal number of NEW states that can be generated by action of the Hamiltonian on the
   // basis state = VOL. In addition, the lambda counts the number of flippable terms in the state.

   // flip(x)=1 (anti-clockwise), -1 (clockwise), 0 (non-flippable) for the k-th basis state
   std::vector<int> xfl(VOL);
   // variables for storing the plaquette correlation functions
   int ood1,ood2,ooh1,ooh2,oov1,oov2;

   int x,y;
   bool f1,f2;

   printf("Construct Hamiltonian in sector %d with basis states =%ld. \n",sector,Wind[sector].nBasis);
   curr_index=1;
   Wind[sector].rows.push_back(curr_index);
   // scan through the basis vectors in this sector
   for(i=0;i<Wind[sector].nBasis;i++){
      newstate = Wind[sector].basisVec[i];

      /* act on the basis state with the Hamiltonian */
      /* a single plaquette is arranged as
                pzw
             o-------o
             |       |
        pwx  |   p   |  pyz
             |       |
             o-------o
                pxy
      */
      for(j=0;j<=VOL;j++) rowscan[j]=NTOT;
      stateq = 0;
      for(p=0;p<VOL;p++){
       xfl[p]=0; // initially assume it is not flippable
       // Find if a single plaquette is flippable
       p1=2*p; p2=2*next[DIM+1][p]+1; p3=2*next[DIM+2][p]; p4=2*p+1;
       pxy=newstate[p1]; pyz=newstate[p2]; pzw=newstate[p3]; pwx=newstate[p4];
       if((pxy==pyz)&&(pzw==pwx)&&(pwx!=pxy)){
         // If flippable, act with the Hamiltonian
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2];
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
         // check which state it is by scanning other states in the same sector
         // use the bin search if the basis states are sorted; it is much faster
         //q=Wind[sector].scan(newstate);
         q=Wind[sector].binscan(newstate);

	 // sanity checks DELETE LATER!
	 //chk1=Wind[sector].scan(newstate);
	 //chk2=Wind[sector].binscan2(newstate);
	 //if(chk1!=q) std::cout<<"Mismatch binscan vs scan. q="<<q<<" chk1="<<chk1<<std::endl;
	 //if(chk2!=q) std::cout<<"Mismatch binscan vs binscan2. q="<<q<<" chk2="<<chk2<<std::endl;

         // store the position matrix element (i,stateq)
         rowscan[stateq]=q; stateq++;
         //flip back the plq
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2];
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
         //if(newstate!=basis_flip[i]) std::cout<<"state mismatch"<<std::endl;

         // reset flippability info
         if(pxy) xfl[p]= 1;
         else    xfl[p]=-1;
       } // close if-statement
     } // close for loop over p VOL

     // store the info about the flippability of the basis state
     Wind[sector].xflip.push_back(xfl);

     //store the diagonal location
     rowscan[stateq]=i; stateq++;
     // get the #-of-flippable plaquettes of the basis state-i
     n_Flip=Wind[sector].nflip[i];
     // check
     if(stateq > (VOL+1)){ printf("Error in bound.\n"); }
     // sort the matrix columns
     std::sort (rowscan.begin(), rowscan.end());
     // construct the matrix in CSC format
     curr_index = curr_index + stateq;
     Wind[sector].rows.push_back(curr_index);
     for(k=0;k<stateq;k++){
       Wind[sector].cols.push_back(rowscan[k]+1);
       if(rowscan[k]==i) Wind[sector].hamil.push_back(lam*n_Flip);
       else Wind[sector].hamil.push_back(-1.0);
     }

     //compute the correlation functions, using the depicted scheme
     /*  Schematic set-up of the diagonal correlators
           |======|======|
           |  p4  |  p3  |
           |======|======|
           |  p1  |  p2  |
           |======|======|
           OOd1 = < flip(p1) * flip(p3) >; OOd2 = < flip(p2) * flip(p4) >;
           OOv1 = < flip(p1) * flip(p4) >; OOv2 = < flip(p2) * flip(p3) >;
           OOh1 = < flip(p1) * flip(p2) >; OOh2 = < flip(p3) * flip(p4) >;
     */
     x1=0; y1=0; p1=y1*LX+x1;  x2=1; y2=0; p2=y2*LX+x2;
     x3=1; y3=1; p3=y3*LX+x3;  x4=0; y4=1; p4=y4*LX+x4;
     ood1=xfl[p1]*xfl[p3];  ood2=xfl[p2]*xfl[p4];
     oov1=xfl[p1]*xfl[p4];  oov2=xfl[p2]*xfl[p3];
     ooh1=xfl[p1]*xfl[p2];  ooh2=xfl[p3]*xfl[p4];
     Wind[sector].OOd1.push_back(ood1); Wind[sector].OOd2.push_back(ood2);
     Wind[sector].OOv1.push_back(oov1); Wind[sector].OOv2.push_back(oov2);
     Wind[sector].OOh1.push_back(ooh1); Wind[sector].OOh2.push_back(ooh2);
   }
   //printf("size of rows = %d \n",(int)Wind[sector].rows.size());
   //for(k=0;k<Wind[sector].rows.size();k++) printf("row[%d] = %ld \n",k,Wind[sector].rows[k]);
   //printf("size of cols = %d \n",(int)Wind[sector].cols.size());
   //for(k=0;k<Wind[sector].cols.size();k++) printf("col[%d] = %ld; ham[%d] = %lf\n",k, Wind[sector].cols[k],k,Wind[sector].hamil[k]);


   // diagonalize: use RELATIVELY ROBUST REPRESENTATIONS
   //diag_LAPACK(sector, Wind[sector].evals, Wind[sector].evecs);
   diag_LAPACK_RRR(sector, Wind[sector].evals, Wind[sector].evecs);

   // free memory
   newstate.clear(); rowscan.clear(); xfl.clear();
}


// NOTE: while printing out warnings is a *good* thing, here it is not so
// useful, since this routine is called from the function schmidtDecom,
// when the basis states from different subsystems are patched together.
// There is is likely that no actual configs are found. It is better to
// deal with the -100 value (in the case of an error) in the calling routine.
int WindNo::scan(std::vector<bool> &newstate){
   for(int m=0;m<nBasis;m++){
     if(newstate==basisVec[m]) return m;
   }
   //std::cout<<"WindNo::scan. Element not found here!"<<std::endl;
   return -100;
 }

int WindNo::binscan(std::vector<bool> &newstate){
     unsigned int m;
     // binary search of the sorted array
     std::vector<std::vector<bool>>::iterator it;
     //it = std::lower_bound(basisVec.begin(),basisVec.end(),newstate);
     it = std::lower_bound(basisVec.begin(),basisVec.end(),newstate);
     if(it == basisVec.end()){
       //std::cout<<"WindNo::binscan. Element not found here! "<<std::endl;
       return -100;
     }
     else{
       //m  = std::distance(basisVec.begin(),it);
       m  = it-basisVec.begin();
       return m;
     }
}

// Alternate implementation of the search. Find where the required element
// exists in the vector with the iterator, then the index.
int WindNo::binscan2(std::vector<bool> &newstate){
     unsigned int m;
     std::vector<std::vector<bool>>::iterator it;
     it = std::find(basisVec.begin(),basisVec.end(),newstate);
     if(it == basisVec.end()){
       //std::cout<<"WindNo::binscan2. Element not found here! Aborting. "<<std::endl;
       return -100;
     }
     m  = std::distance(basisVec.begin(),it);
     return m;
}

double WindNo::getH(int p,int q){
   double ele;
   double row1,row2;
   int c;

   ele=0.0;
   row1 = rows[p]-1; row2 = rows[p+1]-1;
   for(c=row1;c<row2;c++){
     if((q+1)==cols[c]) { ele=hamil[c]; break; }
   }
   return ele;
}
