/* construct the Hamiltonian matrix from the basis vectors */
// This constructs the Hamiltonian in a chosen winding number basis
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<fstream>
#include<math.h>
#include<vector>
#include<algorithm>
#include "define.h"
#include "ranlxd.h"

void constH(int sector){

   extern void diag_LAPACK(int,std::vector<double>&,std::vector<double>&,std::vector<double>&);

   // workspace variables to construct the Hamiltonian  
   int i,j,k,p,q;
   int p1,p2,p3,p4;
   double n_Flip;
   int stateq,curr_index;
   double ran[1];
   bool pxy,pyz,pzw,pwx;
   std::vector<bool> newstate(2*VOL);
   std::vector<int> rowscan(VOL+1);
   // rowscan stores the elements of the cartoon states generated by the action of the Hamiltonian
   // the maximal number of NEW states that can be generated by action of the Hamiltonian on the
   // basis state = VOL. In addition, the lambda counts the number of flippable terms in the state.
   
   
   printf("Construct Hamiltonian in sector %d with basis states =%ld. \n",sector,Wind[sector].nBasis);
   curr_index=1;
   Wind[sector].rows.push_back(curr_index);
   // scan through the basis vectors in this sector
   for(i=0;i<Wind[sector].nBasis;i++){
      newstate = Wind[sector].basisVec[i];
      /* act on the basis state with the Hamiltonian */
      /* a single plaquette is arranged as 
                pzw
             o-------o
             |       |
        pwx  |   p   |  pyz
             |       |
             o-------o
                pxy
      */
      for(j=0;j<=VOL;j++) rowscan[j]=NTOT;
      stateq = 0;
      for(p=0;p<VOL;p++){
       // Find if a single plaquette is flippable 
       p1=2*p; p2=2*next[DIM+1][p]+1; p3=2*next[DIM+2][p]; p4=2*p+1;
       pxy=newstate[p1]; pyz=newstate[p2]; pzw=newstate[p3]; pwx=newstate[p4];
       if((pxy==pyz)&&(pzw==pwx)&&(pwx!=pxy)){
         // If flippable, act with the Hamiltonian 
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2];
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
         //check which state it is by scanning other states in the same sector
         // use the bin search if the basis states are sorted; it is much faster
         q=Wind[sector].binscan(newstate);
         //q=Wind[sector].scan(newstate);
         // store the position matrix element (i,stateq) 
         rowscan[stateq]=q; stateq++;
         //flip back the plq
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2];
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
       }
     }
     //store the diagonal location
     rowscan[stateq]=i; stateq++;
     // get the contribution of the disordered-lambda 
     n_Flip=Wind[sector].lamH[i];
     // check
     if(stateq > (VOL+1)){ printf("Error in bound.\n"); }
     // sort the matrix columns
     std::sort (rowscan.begin(), rowscan.end()); 
     // construct the matrix in CSC format
     curr_index = curr_index + stateq;
     Wind[sector].rows.push_back(curr_index);
     for(k=0;k<stateq;k++){
       Wind[sector].cols.push_back(rowscan[k]+1);
       if(rowscan[k]==i) Wind[sector].hamil.push_back(n_Flip);
       else Wind[sector].hamil.push_back(-1.0);
     }
   }
   // print the matrix for debugging
   //printf("size of rows = %d \n",(int)Wind[sector].rows.size());
   //for(k=0;k<Wind[sector].rows.size();k++) printf("row[%d] = %d \n",k,Wind[sector].rows[k]);
   //printf("size of cols = %d \n",(int)Wind[sector].cols.size());
   //for(k=0;k<Wind[sector].cols.size();k++) printf("col[%d] = %d \n",k,Wind[sector].cols[k]);

   //diagonalize the Hamiltonian matrix 
   //diag_LAPACK(sector, Wind[sector].hamil, Wind[sector].evals, Wind[sector].evecs);
}

// standard scan
int WindNo::scan(std::vector<bool> &newstate){
     unsigned int m;
     std::vector<std::vector<bool>>::iterator it; 
     it = std::find(basisVec.begin(),basisVec.end(),newstate);
     if(it == basisVec.end()){
       std::cout<<"Element not found here! "<<std::endl; 
       return -100;
     }
     m  = std::distance(basisVec.begin(),it);
     return m;
 }

// binary scan
int WindNo::binscan(std::vector<bool> &newstate){
     unsigned int m;
     // binary search of the sorted array  
     std::vector<std::vector<bool>>::iterator it; 
     it = std::lower_bound(basisVec.begin(),basisVec.end(),newstate);
     m  = std::distance(basisVec.begin(),it);
     return m;
}

void printmatrix(std::vector<MKL_INT> &rows, std::vector<MKL_INT> &cols, std::vector<double> &vals){
 std::ofstream Outfile;
 int nrows, ncols;
 nrows = rows.size(); ncols = cols.size();
 Outfile.open("sparse_mat.bin",std::ios::out);
 Outfile.write((char*)&nrows, sizeof(int));
 Outfile.write((char*)&ncols, sizeof(int));
 Outfile.write((char*)&rows[0], rows.size()*sizeof(MKL_INT));
 Outfile.write((char*)&cols[0], cols.size()*sizeof(MKL_INT));
 Outfile.write((char*)&vals[0], vals.size()*sizeof(double));
 Outfile.close();
}

double WindNo::getH(int p,int q){
   double ele;
   double row1,row2;
   int c;

   ele=0.0;
   row1 = rows[p]-1; row2 = rows[p+1]-1;
   for(c=row1;c<row2;c++){
     if((q+1)==cols[c]) { ele=hamil[c]; break; }
   }
   return ele;
 }

void WindNo::check_getH(){
    int i,j;
    double ele;
    printf("==================\n");
    printf("Printing the full matrix for checking \n");
    for(i=0;i<nBasis;i++){
    for(j=0;j<nBasis;j++){
      ele = getH(i,j);   
      printf("% .1lf ",ele);
    }
    printf("\n");
  }
} 
